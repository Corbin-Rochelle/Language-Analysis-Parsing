//**************************************************************************
 
// purpose: This is the logic behind the parser, with lots of delicate code.
// version: Fall 2023
//  author: Corbin Rochelle

//**************************************************************************
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include "lexer.h"
#include "parser.h"
 
using namespace std;

int nextToken = 0;            // hold nextToken returned by lex

// Which tree level are we currently in?  
static int level = 0;

// Feel free to use a different data structure for the symbol table (list of
// variables declared in the program) but you will have to adjust the code in
// main() to print out the symbol table after a successful parse
set<string> symbolTable; // Symbol Table

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
bool first_of_program(void);

void lex() {
    nextToken = yylex();
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> → TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
void program() 
{
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    
    if (nextToken != TOK_PROGRAM) throw("3: 'PROGRAM' expected");
    output("PROGRAM");
    
    cout << psp() << "enter <program>" << endl;
    ++level;

    lex();
    output("IDENTIFIER");
    lex();
    if (nextToken != TOK_SEMICOLON) throw ("14: ';' expected");
    output("SEMICOLON");
    lex();
    output("BLOCK");
    block();

    --level;
    cout << psp() << "exit <program>" << endl;
    lex();
    
}
bool first_of_program(void) {
    return nextToken == TOK_PROGRAM;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <block> → stuff
void block() {
    string ident, typer;
    
    cout << psp() << "enter <block>" << endl;
    ++level;
    
    if (nextToken != TOK_VAR && nextToken != TOK_BEGIN) throw("18: error in declaration part OR 17: 'BEGIN' expected");
    bool checker = true;
    if (nextToken == TOK_BEGIN) {
        checker = false;    }
    else lex();
    
   
    while(checker) {
        if (nextToken != TOK_IDENT) throw ("2: identifier expected");
        output("IDENTIFIER");
        ident = yytext;
        lex();
        if (nextToken != TOK_COLON) throw ("5: ':' expected");
        output("COLON");
        lex();
        if (nextToken != TOK_INTEGER && nextToken != TOK_REAL) throw ("10: error in type");
        output("TYPE");
        typer = yytext;
        lex();
        if (nextToken != TOK_SEMICOLON) throw ("14: ';' expected");
        output("SEMICOLON");
        lex();
        cout << psp() << "-- idName: |" << ident << "| idType: |" << typer << "| --" << endl;
        if (symbolTable.find(ident) != symbolTable.end()) {
            yytext = (char *)";";
            throw ("101: identifier declared twice");
        }
        symbolTable.insert(ident);

        if (nextToken == TOK_BEGIN) {
            checker = false;
        }
    }
    
    checker = true;
    statement();
    while(checker){
        if (nextToken == TOK_END) {
            checker = false;
            break;
        }
        if (nextToken != TOK_SEMICOLON) throw("14: ';' expected");
        output("SEMICOLON");
        statement();
    }
    
    --level;
    cout << psp() << "exit <block>" << endl;
    
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <statement> → stuff
void statement() {
    bool skipper = false;
    bool looper = true;
    switch(nextToken) {
        case TOK_BEGIN:
            output("BEGIN");
            cout << psp() << "enter <compound_stmt>" << endl;
            ++level;

            
            while(looper){
                lex();
                output("STATEMENT");
                statement();
                if (nextToken != TOK_SEMICOLON) looper = false;
                if (looper) output("SEMICOLON");
            }
            
            --level;
            if (nextToken != TOK_END) {
                throw("13: 'END' expected");
            }
            output("END");
            cout << psp() << "exit <compound_stmt>" << endl;
            lex();
            if (strcmp(yytext,"") == 0) nextToken = TOK_END;
            
            break;
            
        case TOK_IF:
            cout << psp() << "enter <if>" << endl;
            ++level;
            
            lex();
            output("EXPRESSION");
            expression();
            if (nextToken != TOK_THEN) throw("52: 'THEN' expected");
            output("THEN");
            lex();
            output("STATEMENT");
            statement();
            if (nextToken == TOK_ELSE) skipper = true;
            if (skipper) {
                --level;
                output("ELSE");
                cout << psp() << "enter <else>" << endl;
                ++level;
                lex();
                output("STATEMENT");
                statement();
            }
            --level;
            cout << psp() << "exit <if>" << endl;
            break;
        
            
        case TOK_WHILE:
            cout << psp() << "enter <while>" << endl;
            ++level;
            
            lex();
            output("EXPRESSION");
            expression();
            output("STATEMENT");
            statement();
            --level;
            cout << psp() << "exit <while>" << endl;
            break;
            
        case TOK_READ:
            cout << psp() << "enter <read>" << endl;
            ++level;
            
            lex();
            if (nextToken != TOK_OPENPAREN) throw("9: '(' expected");
            output("OPENPAREN");
            lex();
            if (symbolTable.find(yytext) == symbolTable.end()) throw ("104: identifier not declared");
            output("IDENTIFIER");
            cout << psp() << yytext << endl;
            lex();
            if (nextToken != TOK_CLOSEPAREN) throw("4: ')' expected");
            output("CLOSEPAREN");
            lex();
            
            --level;
            cout << psp() << "exit <read>" << endl;
            break;
            
        case TOK_WRITE:
            cout << psp() << "enter <write>" << endl;
            ++level;
            lex();
            if (nextToken != TOK_OPENPAREN) throw("9: '(' expected");
            output("OPENPAREN");
            lex();
            output("WRITE");
            cout << psp() << yytext << endl;
            lex();
            if (nextToken != TOK_CLOSEPAREN) throw("4: ')' expected");
            output("CLOSEPAREN");
            lex();
            --level;
            cout << psp() << "exit <write>" << endl;
            break;
            
        case TOK_IDENT:
            cout << psp() << "enter <assignment>" << endl;
            ++level;
            
            if (symbolTable.find(yytext) == symbolTable.end()) throw ("104: identifier not declared");
            output("IDENTIFIER");
            cout << psp() << yytext << endl;
            lex();
            if(nextToken != TOK_ASSIGN) throw("51: ':=' expected");
            output("ASSIGN");
            lex();
            output("EXPRESSION");
            expression();
            
            --level;
            cout << psp() << "exit <assignment>" << endl;
            break;
        default:
            throw("900: illegal type of statement");
    }
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <expression> → stuff
void expression() {
    cout << psp() << "enter <expression>" << endl;
    ++level;
    
    output("SIMPLE_EXP");
    simple_expression();
    
    bool checker = false;
    switch(nextToken) {
        case TOK_EQUALTO:
            output("EQUALTO");
            cout << psp() << yytext << endl;
            checker = true;
            break;
        case TOK_LESSTHAN:
            output("LESSTHAN");
            cout << psp() << yytext << endl;
            checker = true;
            break;
        case TOK_GREATERTHAN:
            output("GREATERTHAN");
            cout << psp() << yytext << endl;
            checker = true;
            break;
        case TOK_NOTEQUALTO:
            output("NOTEQUALTO");
            cout << psp() << yytext << endl;
            checker = true;
            break;
    }
    
    if(checker) {
        lex();
        output("SIMPLE_EXP");
        simple_expression();
    }
    
    
    --level;
    cout << psp() << "exit <expression>" << endl;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <simple_expression> → stuff
void simple_expression() {
    cout << psp() << "enter <simple_exp>" << endl;
    ++level;
    
    output("TERM");
    term();
    
    bool outerloop = true;
    
    while(outerloop) {
        bool checker = false;
        switch(nextToken) {
            case TOK_PLUS:
                output("PLUS");
                cout << psp() << yytext << endl;
                checker = true;
                lex();
                break;
            case TOK_MINUS:
                output("MINUS");
                cout << psp() << yytext << endl;
                checker = true;
                lex();
                break;
            case TOK_OR:
                output("OR");
                checker = true;
                lex();
                break;
        }
        
        if(checker) {
            output("TERM");
            term();
        }
        
        if (nextToken != TOK_PLUS || nextToken != TOK_MINUS || nextToken != TOK_OR) outerloop = false;
    }
    
    --level;
    cout << psp() << "exit <simple_exp>" << endl;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <term> → stuff
void term() {
    cout << psp() << "enter <term>" << endl;
    ++level;
    
    output("FACTOR");
    factor();
    
    bool outerloop = true;
    
    lex();
    while(outerloop) {
        switch(nextToken) {
            case TOK_MULTIPLY:
                output("MULTIPLY");
                cout << psp() << yytext << endl;
                lex();
                output("FACTOR");
                factor();
                lex();
                break;
            case TOK_DIVIDE:
                output("DIVIDE");
                cout << psp() << yytext << endl;
                lex();
                output("FACTOR");
                factor();
                lex();
                break;
            case TOK_AND:
                output("AND");
                lex();
                output("FACTOR");
                factor();
                lex();
                break;
        }
        
        if (nextToken != TOK_MULTIPLY && nextToken != TOK_DIVIDE && nextToken != TOK_AND) outerloop = false;
    }
    
    --level;
    cout << psp() << "exit <term>" << endl;
}
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <factor> → stuff
void factor() {
    cout << psp() << "enter <factor>" << endl;
    ++level;
    
    switch(nextToken) {
        case TOK_INTLIT:
            output("INTLIT");
            cout << psp() << yytext << endl;
            break;
        case TOK_FLOATLIT:
            output("FLOATLIT");
            cout << psp() << yytext << endl;
            break;
        case TOK_IDENT:
            output("IDENTIFIER");
            cout << psp() << yytext << endl;
            if (symbolTable.find(yytext) == symbolTable.end()) throw ("104: identifier not declared");
            break;
        case TOK_OPENPAREN:
            output("OPENPAREN");
            cout << psp() << yytext << endl;
            lex();
            output("EXPRESSION");
            expression();
            if (nextToken != TOK_CLOSEPAREN) throw("4: ')' expected");
            output("CLOSEPAREN");
            break;
        case TOK_NOT:
            lex();
            factor();
            break;
        case TOK_MINUS:
            output("MINUS");
            cout << psp() << yytext << endl;
            lex();
            output("FACTOR");
            factor();
            break;
        default:
            throw("903: illegal type of factor");
    }
    
    --level;
    cout << psp() << "exit <factor>" << endl;
}
