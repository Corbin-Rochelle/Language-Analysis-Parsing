//**************************************************************************
 
// Replace with appropriate header comment......

//**************************************************************************
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include "lexer.h"
#include "parser.h"
 
using namespace std;

int nextToken = 0;            // hold nextToken returned by lex

// Which tree level are we currently in?  
static int level = 0;

// Feel free to use a different data structure for the symbol table (list of
// variables declared in the program) but you will have to adjust the code in
// main() to print out the symbol table after a successful parse
set<string> symbolTable; // Symbol Table

//*****************************************************************************
// Indent to reveal tree structure
string psp(void) { // Stands for p-space, but I want the name short
  string str("");
  for(int i = 0; i < level; i++)
    str += "|  ";
  return str;
}
//*****************************************************************************
// Report what we found
void output(string what) {
  cout << psp() << "found |" << yytext << "| " << what << endl;
}
//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current 
// token is in the FIRST set of a production rule.
bool first_of_program(void);
//*****************************************************************************
// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
void program() 
{
    if (!first_of_program()) // Check for PROGRAM
        throw "3: 'PROGRAM' expected";
    
    cout << psp() << "enter <program>" << endl;
    ++level;

    // TODO: finish this parsing function...

    --level;
    cout << psp() << "exit <program>" << endl;
    
}
bool first_of_program(void) {
    return nextToken == TOK_PROGRAM;
}
